(function(){"use strict";function F(n,f){if(f<0||f>=n.length)throw RangeError("Out of bound");const h=n.slice();n.sort((c,o)=>c-o);const a={};for(let c=n.length-1;c>=0;c-=1)a[n[c]]=c;const u=[];for(let c=0;c<n.length;c+=1)u.push(a[h[c]]++);let r;const t=n[r=f],g=[];for(let c=1;c<n.length;c+=1){const o=n[r=u[r]];o===void 0?g.push(255):g.push(o)}return g.push(t),g.reverse(),g}function G(n){const f=[];for(let o=0;o<n.length;o+=1)f.push([o,n[o]]);f.push([n.length,-1]);const h=[];let a=f[0][0],u=f[0][1];for(let o=0;o<f.length;o+=1){const l=f[o][0],b=f[o][1];if(u)for(let E=a;E<l;E+=1)h.push({code:E,bits:u,symbol:void 0});if(a=l,u=b,b===-1)break}h.sort((o,l)=>o.bits-l.bits||o.code-l.code);let r=0,t=-1;const g=[];let c;for(let o=0;o<h.length;o+=1){const l=h[o];t+=1,l.bits!==r&&(t<<=l.bits-r,r=l.bits,c=g[r]={}),l.symbol=t,c[t]=l}return{table:h,fastAccess:g}}const R=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215,33554431,67108863,134217727,268435455,536870911,1073741823,-2147483648];function _(n,f){const h=performance.now();let a=0,u=0,r=0;const t=d=>{if(d>=32){const j=d>>1;return t(j)*(1<<j)+t(d-j)}for(;r<d;)u=(u<<8)+n[a],a+=1,r+=8;const I=R[d],m=u>>r-d&I;return r-=d,u&=~(I<<r),m};if(t(16)!==16986)throw new Error("Invalid magic");if(t(8)!==104)throw new Error("Invalid method");let o=t(8);if(o>=49&&o<=57)o-=48;else throw new Error("Invalid blocksize");let l=new Uint8Array(n.length*1.5),b=0;for(;;){const d=t(48);if(t(32)|0,f(a/n.length),d===54156738319193){if(t(1))throw new Error("do not support randomised");const I=t(24),m=[],j=t(16);for(let e=32768;e>0;e>>=1){if(!(j&e)){for(let i=0;i<16;i+=1)m.push(!1);continue}const s=t(16);for(let i=32768;i>0;i>>=1)m.push(!!(s&i))}const A=t(3);if(A<2||A>6)throw new Error("Invalid number of huffman groups");const q=t(15),T=[],z=Array.from({length:A},(e,s)=>s);for(let e=0;e<q;e+=1){let s=0;for(;t(1);)if(s+=1,s>=A)throw new Error("MTF table out of range");const i=z[s];for(let y=s;y>0;z[y]=z[--y]);T.push(i),z[0]=i}const B=m.reduce((e,s)=>e+s,0)+2,C=[];for(let e=0;e<A;e+=1){let s=t(5);const i=[];for(let y=0;y<B;y+=1){if(s<0||s>20)throw new Error("Huffman group length outside range");for(;t(1);)s-=t(1)*2-1;i.push(s)}C.push(G(i))}const k=[];for(let e=0;e<m.length-1;e+=1)m[e]&&k.push(e);let U=0,x=0,O,p,P=0,M=0;const H=[];for(;;){U-=1,U<=0&&(U=50,x<=T.length&&(O=C[T[x]],x+=1));for(const e in O.fastAccess)if(Object.prototype.hasOwnProperty.call(O.fastAccess,e)&&(r<e&&(u=(u<<8)+n[a],a+=1,r+=8),p=O.fastAccess[e][u>>r-e],p)){u&=R[r-=e],p=p.code;break}if(p>=0&&p<=1){P===0&&(M=1),P+=M<<p,M<<=1;continue}else{const e=k[0];for(;P>0;P-=1)H.push(e)}if(p===B-1)break;{const e=k[p-1];for(let s=p-1;s>0;k[s]=k[--s]);k[0]=e,H.push(e)}}const v=F(H,I);let w=0;for(;w<v.length;){const e=v[w];let s=1;if(w<v.length-4&&v[w+1]===e&&v[w+2]===e&&v[w+3]===e?(s=v[w+4]+4,w+=5):w+=1,b+s>=l.length){const i=l;l=new Uint8Array(i.length*2),l.set(i)}for(let i=0;i<s;i+=1)l[b]=e,b+=1}}else if(d===25779555029136){t(r&7);break}else throw new Error("Invalid bz2 blocktype")}const E=performance.now();return console.log("Total decompression done in",E-h,"ms"),l.subarray(0,b)}self.onmessage=n=>{const f=_(n.data,h=>{self.postMessage({type:"progress",progress:h})});self.postMessage({type:"result",result:f})}})();
